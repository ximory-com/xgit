# XGIT 补丁协议技术规范 v1.0（基于代码反向生成）
## 1. 协议概述
XGIT 补丁协议是一套基于文本的代码仓库操作指令规范，旨在为 AI 驱动的代码修改提供标准化交互接口，支持文件操作、Git 版本控制及行级精准编辑。协议核心特性包括事务性执行、严格格式校验、智能错误处理及扩展式预检能力，可通过补丁文件驱动 `patchd` 守护进程完成自动化代码变更。

## 2. 系统架构
### 2.1 核心组件
- **patchd 守护进程**：监听指定补丁文件（默认 `文本.txt`），执行文件稳定检测与补丁处理调度（`main.go`）。
- **解析器**：负责补丁文本的格式校验与结构化解析，输出 `Patch` 与 `FileOp` 对象（`parser.go`）。
- **执行器**：按指令类型分发至对应处理模块（fileops/gitops），管理 Git 事务与错误回滚（`dispatch.go`+`helper.go`）。
- **预检系统**：针对不同文件类型执行格式校验与自动修复，支持插件式扩展（`preflight` 包）。
- **日志系统**：实现控制台与文件（`patch.log`）双重输出，记录操作时间戳与执行详情（`logging.go`）。
- **进程管理**：通过 PID 文件（`.xgit_patchd.pid`）实现守护进程的启停与状态查询（`pidutil.go`）。

### 2.2 执行流程

A[补丁文件生成] --> B[文件稳定检测]
B --> C[严格 EOF 校验]
C --> D[补丁解析与验证]
D --> E[Git 事务初始化]
E --> F[指令分发执行]
F --> G[文件预检处理]
G --> H[暂存区变更检测]
H --> I[Git 提交与推送]
I --> J[执行完成]
F --> K[错误回滚]
K --> L[终止并记录日志]

## 3. 补丁文件格式规范
### 3.1 整体结构

repo: <仓库名称>
commitmsg: <提交信息>
author: <作者信息>
=== <指令类型>: "<目标路径>" ===
[参数1=值1]
[参数2<
  多行参数内容（单个空格缩进开头）
>参数2]
[正文内容]
=== end ===
=== PATCH EOF ===

### 3.2 头部字段
| 字段名 | 含义 | 默认值 | 优先级 |
|--------|------|--------|--------|
| `repo` | 目标仓库标识，映射至 `.repos` 配置 | - | 1. Patch.Repo → 2. 头部 `repo:` → 3. `.repos` default |
| `commitmsg` | Git 提交说明 | "chore: apply file ops patch" | 补丁头部定义优先 |
| `author` | 提交作者信息（格式："Name <email>"） | "XGit Bot <bot@xgit.local>" | 补丁头部定义优先 |

### 3.3 指令块语法
- **块头**：以 `=== <指令>: "<路径>" ===` 开头，路径必须用双引号包裹，指令区分大小写（`parser.go`）。
- **参数区**：支持单行参数（`K=V`）与多行参数（`K<...>K`），多行内容需以空格开头，参数键统一转为小写。
- **正文区**：参数区结束后至 `=== end ===` 之间的内容，用于存储文件内容、diff 文本等核心数据。
- **块尾**：以 `=== end ===` 标识单个指令结束，整个补丁以 `=== PATCH EOF ===` 收尾（严格校验）。

## 4. 核心指令集
### 4.1 文件操作指令（`file.*`）
| 指令 | 功能 | 必需参数 | 特性 |
|------|------|----------|------|
| `file.write` | 创建或覆盖文件 | - | 自动创建目录（755）、统一 LF 换行、确保末尾换行、执行预检（`fileops/write.go`） |
| `file.append` | 向文件末尾追加内容 | - | 读取原有内容后合并写入，保持换行规范（`fileops/append.go`） |
| `file.prepend` | 向文件开头插入内容 | - | 不存在时等价于 `file.write`，合并内容后覆盖写入（`fileops/prepend.go`） |
| `file.delete` | 删除文件/目录 | - | 递归删除目标，自动清理空父目录（`fileops/delete.go`） |
| `file.move` | 移动/重命名文件 | `to`（目标路径） | 支持跨目录操作，自动创建目标目录（`fileops/move.go`） |
| `file.chmod` | 修改文件权限 | `mode`（八进制权限值） | 直接变更文件权限，如 644、755（`fileops/chmod.go`） |
| `file.eol` | 统一换行符格式 | `style`（lf/crlf，默认 lf）、`ensure_nl`（是否确保末尾换行，默认 true） | 按参数转换换行符，支持格式保持（`fileops/eol.go`） |
| `file.binary` | 写入二进制文件 | - | 正文为 Base64 编码数据，解码后写入文件（`fileops/binary.go`） |
| `file.image` | 写入图片文件 | - | 语义同 `file.binary`，后续可扩展图片校验（`fileops/image.go`） |

### 4.2 Git 操作指令（`git.*`）
| 指令 | 功能 | 必需参数 | 特性 |
|------|------|----------|------|
| `git.diff` | 应用 Git diff 补丁 | - | 正文为标准 diff 格式，支持围栏自动剥离、多策略重试、文件存在性预检（`gitops/diff.go`） |
| `git.reset` | 重置仓库至指定提交 | `ref`（目标提交）、`mode`（hard/mixed/soft，默认 hard） | 对应 Git 原生 `git reset` 功能（`gitops/reset.go`） |
| `git.revert` | 撤销指定提交更改 | `ref`（目标提交）、`no_commit`（是否不自动提交，默认 false） | 对应 Git 原生 `git revert` 功能，支持批量撤销（`gitops/revert.go`） |
| `git.tag` | 创建/更新 Git 标签 | `name`（标签名） | 支持轻量/附注标签，可配置强制覆盖与远端推送（`gitops/tag.go`） |
| `git.commit` | 提交占位符 | - | 必须单独作为补丁唯一指令，实际提交由系统统一处理（`dispatch.go`） |

### 4.3 行级编辑指令（`line.*`/`block.*`）
#### 4.3.1 通用参数
| 参数 | 含义 | 适用指令 |
|------|------|----------|
| `lineno` | 作用域内相对行号（1-based） | 所有 line.* 指令 |
| `keys` | 关键字匹配（支持 `|`/`,` 分隔） | 所有 line.* 指令 |
| `nthl` | 多关键字匹配时的选择序号（1-based，默认取首个） | line.* 指令 |
| `offset` | 行偏移（格式 `+N` 或 `-N`，N 为正整数） | 无作用域时的 line.* 指令 |
| `start-keys` | 作用域起始关键字（支持 `|`/`,`/换行分隔） | 所有 block.* 指令 + 行级指令 |
| `end-keys` | 作用域结束关键字（支持 `|`/`,`/换行分隔，可选） | 所有 block.* 指令 + 行级指令 |
| `nthb` | 多作用域匹配时的选择序号（1-based，默认取首个） | block.* 指令 |

#### 4.3.2 关键字匹配核心规则（`keys`/`start-keys`/`end-keys`）
### 4.3.2.1 关键字解析规则
1.  **分隔符处理**：自动识别并拆分多种分隔符，统一转为“备选关键字集”：
    - 竖线（`|`）：表示“或”关系，如 `key1|key2` 拆分为 `[key1, key2]`
    - 逗号（`,`）：表示“或”关系，如 `key1,key2` 拆分为 `[key1, key2]`
    - 换行：表示“或”关系，多行关键字自动合并为备选集，如：
      ```
      start-keys=key1
      key2
      ```
      拆分为 `[key1, key2]`
2.  **预处理逻辑**：
    - 自动剔除空字符串：过滤拆分后全空白的关键字（如 `key1,,key2` 拆分为 `[key1, key2]`）
    - 大小写忽略：匹配时不区分大小写（如 `KEY1` 与 `key1` 视为同一关键字）
    - 缩进忽略：匹配时忽略行首空格/制表符（如 `  func() {}` 与 `func() {}` 视为同一行）

### 4.3.2.2 `keys` 匹配规则（行级定位）
`keys` 用于 line.* 指令的目标行定位，采用“宽松唯一命中”策略，优先级从高到低如下：
1.  **单关键字唯一匹配**：遍历备选关键字集，若任一关键字单独命中且仅命中 1 行，则取该行为目标行。
    - 示例：`keys=func Shell`，若文件中仅 1 行包含“func Shell”，直接定位该行。
2.  **双关键字 AND 匹配**：若单关键字无唯一命中，取备选集中所有双关键字组合，执行“AND 匹配”（同一行包含两个关键字），若某组合唯一命中，则取该行为目标行。
    - 示例：`keys=func|Shell,error` 拆分为 `[func, Shell, error]`，尝试 `func+Shell`、`func+error`、`Shell+error` 组合，若仅 `func+error` 唯一命中某行，则定位该行。
3.  **全关键字 AND 匹配**：若双关键字组合无唯一命中，检查是否所有备选关键字均存在于同一行，若唯一命中则取该行。
    - 示例：`keys=func,Shell,error`，若仅 1 行同时包含三个关键字，定位该行。
4.  **多匹配处理**：
    - 若匹配结果为多行，且指定 `nthl` 参数，则取第 `nthl` 行（1-based）。
    - 若未指定 `nthl`，则报错并返回所有匹配行号（如“keys 多处命中 [3,5,7]（可用 nthl=1..3 选择）”）。
5.  **匹配范围约束**：仅在当前作用域内执行匹配（无作用域时为全文），超出作用域的命中行自动过滤。

### 4.3.2.3 `start-keys`/`end-keys` 匹配规则（作用域定位）
`start-keys` 与 `end-keys` 用于定义块级/行级指令的作用域（`[start, end]` 闭区间，1-based），规则如下：
#### 1. `start-keys` 定位规则
- 核心逻辑：采用与 `keys` 相同的“宽松唯一命中”策略，但必须返回唯一行（或通过 `nthb` 指定）。
- 多匹配处理：
  - 若匹配多行，必须通过 `nthb` 参数指定选择序号（如 `nthb=2` 取第 2 个匹配行）。
  - 未指定 `nthb` 时直接报错（如“start-keys 定位失败：多处命中 [3,5]（需指定 nthb=1..2）”）。
- 范围约束：起始行必须在文件有效范围内（1 ≤ start ≤ 总行数），否则报错“起点超界”。

#### 2. `end-keys` 定位规则
- 搜索范围：仅在 `start-keys` 定位的起始行之后搜索（`end ≥ start`），避免反向范围。
- 匹配策略：采用“宽松首次命中”策略，即按与 `keys` 相同的匹配逻辑，取第一个符合条件的行作为结束行。
- 缺省处理：未指定 `end-keys` 时，结束行默认为文件最后一行（`end = 总行数`）。
- 异常处理：起始行后无匹配行时报错（如“end-keys 定位失败：起始行 3 后无匹配”）；结束行 < 起始行时报错“非法范围：end(2) < start(3)”。

#### 3. 作用域生效规则
| 配置场景 | 作用域范围 | 示例 |
|----------|------------|------|
| 有 `start-keys`，无 `end-keys` | `[start, 总行数]` | `start-keys=func Shell` → 从 Shell 函数定义行到文件末尾 |
| 有 `start-keys`，有 `end-keys` | `[start, end]`（end ≥ start） | `start-keys=func Shell,end-keys=}` → Shell 函数的完整代码块 |
| 无 `start-keys`，无 `end-keys` | `[1, 总行数]`（全文） | 未指定任何作用域参数 → 操作范围为整个文件 |

### 4.3.3 指令详情
| 指令 | 功能 | 核心逻辑 |
|------|------|----------|
| `line.insert` | 在目标行前插入内容 | 按 `keys`/`lineno` 定位目标行，在其前插入正文内容（支持多行） |
| `line.append` | 在目标行后插入内容 | 定位目标行后追加正文，支持多行插入 |
| `line.replace` | 替换目标行内容 | 用正文替换定位到的单行，支持多行替换（原单行被替换为多行正文） |
| `line.delete` | 删除目标行 | 定位目标行后移除，更新文件内容并确保末尾换行 |
| `block.delete` | 删除指定作用域内容 | 解析 `start-keys`/`end-keys` 确定范围，批量删除范围内所有行 |
| `block.replace` | 替换指定作用域内容 | 用正文替换作用域内所有内容，保持文件格式规范 |

## 5. 执行约束与规则
### 5.1 指令约束
- `lineno` 相关指令：同一补丁中最多 1 个，且必须作为首个指令（`apply.go`）。
- `git.commit` 指令：必须单独构成补丁，不可与其他指令混合（`apply.go`）。
- 参数冲突规则：有作用域时禁用 `offset`；`lineno` 优先级高于 `keys`（`fileops/lineutils.go`）。

### 5.2 事务规则
- **清理策略**：`CleanAtStart=true` 时，执行 `git reset --hard` + `git clean -fd` 清理工作区（`helper.go`）。
- **回滚机制**：`RollbackOnError=true` 时，失败后回滚至补丁执行前的 HEAD 状态（`helper.go`）。
- **提交流程**：统一执行 `git add -A` 暂存变更，无改动时跳过提交（`apply.go`）。

### 5.3 错误处理
- 解析错误：格式不符合规范时立即终止，返回具体行号与原因（`parser.go`）。
- 定位错误：行/块定位失败时严格报错，不支持静默跳过（`fileops/lineutils.go`）。
- 执行错误：任一指令失败触发事务回滚，记录错误上下文与回滚状态（`apply.go`）。

## 6. 预检系统规范
### 6.1 核心能力
- **语言适配**：基于文件扩展名自动匹配预检器（Go→gofmt、JSON→格式化）（`preflight/registry.go`）。
- **原子操作**：采用临时文件写入+重命名机制，保持文件权限与修改时间（`preflight/util.go`）。
- **插件扩展**：通过实现 `Runner` 接口注册自定义预检器，支持新增格式校验（`preflight/registry.go`）。

### 6.2 内置预检器
| 预检器 | 适配文件 | 功能 |
|--------|----------|------|
| `go-fmt` | `.go` | 执行 `go/format` 格式化，统一末尾换行（`preflight/go.go`） |
| `json-pretty` | `.json` | 解析校验 JSON 语法，输出 2 空格缩进的格式化内容（`preflight/json.go`） |

## 7. 配置文件规范
### 7.1 仓库映射文件（`.repos`）
- 格式：支持注释（`#` 开头）、空行忽略，包含默认仓库与映射关系。
- 语法：

# 注释
default = 默认仓库名
仓库名1 /绝对路径1
仓库名2 /绝对路径2

- 解析逻辑：优先匹配补丁指定仓库，无则使用默认配置（`repos.go`）。

### 7.2 进程配置
- PID 文件：`.xgit_patchd.pid` 存储当前守护进程 PID，用于启停与状态查询（`pidutil.go`）。
- 哈希记录：`.lastpatch` 存储上一次处理的补丁 MD5 前 8 位，避免重复执行（`main.go`）。

## 8. 扩展性设计
### 8.1 指令扩展
- 新增指令需在 `dispatch.go` 的 `applyOp` 函数中添加分支，关联处理逻辑。
- 自定义指令需实现参数解析与执行函数，遵循 `FileOp` 数据结构规范。

### 8.2 预检扩展
- 新增预检器需实现 `Runner` 接口（`Name()`/`Match()`/`Run()`），通过 `init()` 函数注册。
- 支持按文件类型、路径匹配预检器，扩展语法校验或格式化能力。

## 9. 协议兼容性说明
- 换行符兼容：解析阶段自动归一化 `\r\n` 为 `\n`，执行阶段按配置保持格式。
- 路径兼容：支持带空格的文件路径，需用双引号包裹（`parser.go`）。
- 版本兼容：指令集向下兼容，新增指令不影响旧补丁执行。

