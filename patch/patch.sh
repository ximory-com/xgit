#!/usr/bin/env bash
# XGit patch.sh (STRICT v1.6.4)
# - ‰∫ãÂä°ÔºöÂ§±Ë¥•Âç≥Êï¥ÂçïÂõûÊªöÔºàtrap ERRÔºâ+ EXIT ÂÖúÂ∫ï
# - Âπ≤ÂáÄÁ≠ñÁï• REQUIRE_CLEANÔºö1(ÈªòËÆ§)=ÊãíÁªùËÑèÂå∫ | auto=reset --hard + clean -fd | 0=ÂøΩÁï•
# - ÂÉµÂ∞∏ÈîÅËá™ÊÑàÔºö.patch.lock/pid ‰∏çÂ≠òÊ¥ªÂàôËá™Âä®Ê∏ÖÈîÅ
# - blockÔºö@index, append_once, ÂµåÂ•óËØÜÂà´, Áº∫Â§±Ëá™Âä®ÂºïÂØº(ÂèØÂõûÊªö)
# - diffÔºöÁªü‰∏ÄË°•‰∏Å git applyÔºàÁº∫ÁúÅ opts ÂÆâÂÖ®ÔºõBash 3.2 ÂÖºÂÆπÔºâ
# - ‰∏•Ê†º EOFÔºõÈªòËÆ§Êé®ÈÄÅÂºÄÂêØ
set -Eeuo pipefail
IFS=$'\n\t'

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd -P)"
PATCH_FILE_DEFAULT="${SCRIPT_DIR}/ÊñáÊú¨.txt"
PATCH_FILE="${PATCH_FILE:-$PATCH_FILE_DEFAULT}"
LOG_FILE="${SCRIPT_DIR}/patch.log"
LOCK_DIR="${SCRIPT_DIR}/.patch.lock"
LOCK_PID="${LOCK_DIR}/pid"
EOF_MARK="${EOF_MARK:-=== PATCH EOF ===}"

ts(){ date '+%F %T'; }
log(){ echo "$(ts) $*" | tee -a "$LOG_FILE"; }

# ---------- ÂçïÂÆû‰æãÈîÅÔºàÂê´ÂÉµÂ∞∏ÈîÅËá™ÊÑàÔºâ ----------
if ! mkdir "$LOCK_DIR" 2>/dev/null; then
  # Â∑≤Â≠òÂú®ÔºõÂà§Êñ≠ÊòØÂê¶ÂÉµÂ∞∏
  if [[ -f "$LOCK_PID" ]]; then
    old_pid="$(cat "$LOCK_PID" 2>/dev/null || true)"
    if [[ -n "${old_pid:-}" ]] && ! ps -p "$old_pid" >/dev/null 2>&1; then
      log "‚ö†Ô∏è Ê£ÄÊµãÂà∞ÂÉµÂ∞∏ÈîÅ(pid=$old_pid)ÔºåËá™Âä®Ê∏ÖÁêÜ‚Ä¶"
      rm -rf "$LOCK_DIR" || true
      mkdir "$LOCK_DIR" || { log "‚ùå Êó†Ê≥ïÈáçÂª∫ÈîÅÁõÆÂΩï"; exit 1; }
    else
      log "‚ùå Â∑≤Êúâ patch ÂÆû‰æãÂú®ËøêË°åÔºåÈÄÄÂá∫„ÄÇ"; exit 1
    fi
  else
    log "‚ö†Ô∏è ÈîÅÁõÆÂΩïÂ≠òÂú®‰ΩÜÊó† pidÔºåÂ∞ùËØïËá™ÊÑà‚Ä¶"
    rm -rf "$LOCK_DIR" || true
    mkdir "$LOCK_DIR" || { log "‚ùå Êó†Ê≥ïÈáçÂª∫ÈîÅÁõÆÂΩï"; exit 1; }
  fi
fi
echo "$$" > "$LOCK_PID"
cleanup_lock(){ rm -rf "$LOCK_DIR" 2>/dev/null || true; }
trap 'cleanup_lock' INT TERM

# ---------- Ë°•‰∏ÅÂ≠òÂú®ÊÄß ----------
if [[ ! -f "$PATCH_FILE" ]]; then
  log "‚ÑπÔ∏è Êú™ÊâæÂà∞Ë°•‰∏ÅÊñá‰ª∂Ôºö$PATCH_FILE"
  log "================ patch.sh end ================"; cleanup_lock; exit 0
fi

# ---------- ÈÄöÁî®Â∑•ÂÖ∑ ----------
trim(){ local s="${1%$'\r'}"; s="${s#"${s%%[![:space:]]*}"}"; s="${s%"${s##*[![:space:]]}"}"; printf '%s' "$s"; }
lower(){ printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }
upper(){ printf '%s' "$1" | tr '[:lower:]' '[:upper:]'; }

norm_path(){ # Ê†áÂáÜÂåñË∑ØÂæÑ + ÂêçÂ≠óÂ§ßÂ∞èÂÜôËßÑËåÉ + ÂéªÈ¶ñÂ∞æÁ©∫ÁôΩ
  local p="$(trim "$1")"
  p="$(printf '%s' "$p" | sed 's#//*#/#g; s#^\./##')"
  local dir base name ext ext_l
  dir="$(dirname "$p")"; base="$(basename "$p")"
  if [[ "$base" == *.* ]]; then name="${base%.*}"; ext="${base##*.}"; else name="$base"; ext=""; fi
  ext_l="$(lower "$ext")"
  if [[ -z "$ext" || "$ext_l" == "md" ]]; then name="$(upper "$name")"; else name="$(lower "$name")"; fi
  local base2="$name"; [[ -n "$ext_l" ]] && base2="${name}.${ext_l}"
  [[ "$dir" == "." ]] && printf '%s\n' "$base2" || printf '%s/%s\n' "$dir" "$base2"
}

ensure_canonical_in_repo(){ # ‰øÆÊ≠£Â§ßÂ∞èÂÜôÂ∑ÆÂºÇ
  local want="$1"; local abs="$REPO/$want"
  mkdir -p "$(dirname "$abs")"
  if [[ -e "$abs" ]]; then return 0; fi
  local parent leaf hit
  parent="$(dirname "$want")"; leaf="$(basename "$want")"
  hit="$( (cd "$REPO/$parent" 2>/dev/null && find . -maxdepth 1 -iname "$leaf" -print | sed 's#^\./##') || true )"
  if [[ -n "$hit" && "$hit" != "$leaf" && -e "$REPO/$parent/$hit" ]]; then
    ( cd "$REPO" && git mv -f "$parent/$hit" "$want" ) || true
  fi
}

first_field(){ sed -n "s/^$1:[[:space:]]*//p; q" "$PATCH_FILE" | head -n1; }
find_git_root(){ local s="$1"; while [[ -n "$s" && "$s" != "/" ]]; do [[ -d "$s/.git" ]] && { echo "$s"; return 0; }; s="$(dirname "$s")"; done; return 1; }
is_repo(){ git -C "$1" rev-parse --is-inside-work-tree >/dev/null 2>&1; }

# ---------- ‰ªìÂ∫ìÂÆö‰ΩçÔºàÊò†Â∞Ñ + ÁºìÂ≠ò + ÂÖÑÂºüÁõÆÂΩï + Âêë‰∏äÊü•ÊâæÔºâ ----------
PATCH_DIR="$(cd "$(dirname "$PATCH_FILE")" && pwd -P)"
MAP_PATCH="$PATCH_DIR/.repos"; MAP_SCRIPT="$SCRIPT_DIR/.repos"; MAP_GLOBAL="$HOME/.config/xgit/repos"
CACHE_PATCH="$PATCH_DIR/.repo";  CACHE_GLOBAL="$HOME/.config/xgit/repo"

repo_from_maps(){ local name="$1"; local f line k v
  for f in "$MAP_PATCH" "$MAP_SCRIPT" "$MAP_GLOBAL"; do
    [[ -f "$f" ]] || continue
    while IFS= read -r line || [[ -n "$line" ]]; do
      line="${line%%#*}"; line="${line%%;*}"; line="$(trim "$line")"; [[ -z "$line" ]] && continue
      if echo "$line" | grep -qE '^[[:space:]]*default[[:space:]]*='; then
        v="$(echo "$line" | sed -E 's/^[[:space:]]*default[[:space:]]*=[[:space:]]*(\S+).*/\1/')"; [[ "$name" == "default" ]] && { printf '%s\n' "$v"; return 0; }
      elif echo "$line" | grep -qE '^[^=[:space:]]+[[:space:]]*='; then
        k="$(echo "$line" | sed -E 's/^([^=[:space:]]+).*/\1/')"; v="$(echo "$line" | sed -E 's/^[^=[:space:]]+[[:space:]]*=[[:space:]]*(.+)$/\1/')"; [[ "$k" == "$name" ]] && { printf '%s\n' "$v"; return 0; }
      elif echo "$line" | grep -qE '^[^[:space:]]+[[:space:]]+/'; then
        k="$(echo "$line" | awk '{print $1}')"; v="$(echo "$line" | sed -E 's/^[^[:space:]]+[[:space:]]+(.+)$/\1/')"; [[ "$k" == "$name" ]] && { printf '%s\n' "$v"; return 0; }
      fi
    done < "$f"
  done
  return 1
}

scan_sibling_repo(){ local base="$1"; local parent="$(dirname "$base")"; local hits=0 last=""
  while IFS= read -r d; do [[ -d "$d/.git" ]] || continue; hits=$((hits+1)); last="$d"; done < <(find "$parent" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)
  [[ $hits -eq 1 ]] && printf '%s\n' "$last" || printf '%s\n' ""
}

candidates=()
[[ -n "${REPO:-}" ]] && candidates+=("$(trim "$REPO")")
REPO_HDR="$(trim "$(first_field repo || true)")"
if [[ -n "$REPO_HDR" ]]; then
  if [[ "$REPO_HDR" = /* ]]; then candidates+=("$REPO_HDR")
  else
    if MAP_PATH="$(repo_from_maps "$REPO_HDR" 2>/dev/null || true)"; then candidates+=("$MAP_PATH")
    elif MAP_DEF_NAME="$(repo_from_maps default 2>/dev/null || true)"; then
      if MAP_DEF_PATH="$(repo_from_maps "$MAP_DEF_NAME" 2>/dev/null || true)"; then candidates+=("$MAP_DEF_PATH"); fi
    fi
  fi
fi
[[ -f "$CACHE_PATCH"  ]] && candidates+=("$(trim "$(cat "$CACHE_PATCH")")")
[[ -f "$CACHE_GLOBAL" ]] && candidates+=("$(trim "$(cat "$CACHE_GLOBAL")")")
sib1="$(scan_sibling_repo "$SCRIPT_DIR")"; [[ -n "$sib1" ]] && candidates+=("$sib1")
sib2="$(scan_sibling_repo "$PATCH_DIR")";  [[ -n "$sib2" ]] && candidates+=("$sib2")
root1="$(find_git_root "$SCRIPT_DIR" || true)"; [[ -n "$root1" ]] && candidates+=("$root1")
root2="$(find_git_root "$PATCH_DIR"  || true)"; [[ -n "$root2" ]] && candidates+=("$root2")

uniq_candidates=()
for c in "${candidates[@]:-}"; do
  [[ -z "$c" ]] && continue
  c="$(python3 - <<'PY' "$c"
import os,sys; print(os.path.realpath(sys.argv[1]))
PY
)"; skip=0
  for u in "${uniq_candidates[@]:-}"; do [[ "$u" == "$c" ]] && { skip=1; break; }; done
  [[ $skip -eq 1 ]] && continue
  uniq_candidates+=("$c")
done

REPO=""
for c in "${uniq_candidates[@]:-}"; do if is_repo "$c"; then REPO="$c"; break; fi; done
if [[ -z "$REPO" ]]; then
  log "‚ùå Êú™ËÉΩËá™Âä®ÂÆö‰Ωç Git ‰ªìÂ∫ìÊ†πÁõÆÂΩï„ÄÇÂèØÂú®Ë°•‰∏ÅÂ§¥ÂÜô repo: /abs/path Êàñ repo: <name>ÔºàÈÖçÂêà .reposÔºâÔºåÊàñÂØºÂá∫ REPO=/abs/path„ÄÇ"
  false
fi
mkdir -p "$(dirname "$CACHE_GLOBAL")"
printf '%s\n' "$REPO" >"$CACHE_PATCH"
printf '%s\n' "$REPO" >"$CACHE_GLOBAL"

log "================ patch.sh begin ================"
log "üìÇ ‰ªìÂ∫ìÊ†πÁõÆÂΩïÔºö$REPO"
log "üìÑ Ë°•‰∏ÅÊñá‰ª∂Ôºö$PATCH_FILE"

# ---------- Êèê‰∫§‰ø°ÊÅØ ----------
COMMIT_MSG="$(trim "$(first_field commitmsg || true)")"
AUTHOR_LINE="$(trim "$(first_field author || true)")"
log "üìù Êèê‰∫§ËØ¥ÊòéÔºö${COMMIT_MSG:-(Á©∫)}"
log "üë§ Êèê‰∫§‰ΩúËÄÖÔºö${AUTHOR_LINE:-(Á©∫)}"

# ---------- ‰∏•Ê†º EOF ----------
LAST_MEANINGFUL_LINE="$(awk 'NF{last=$0} END{print last}' "$PATCH_FILE")"
if [ "${LAST_MEANINGFUL_LINE:-}" != "${EOF_MARK:-}" ]; then
  log "‚ùå ‰∏•Ê†º EOF Ê†°È™åÂ§±Ë¥•ÔºöÊúüÊúõ„Äé${EOF_MARK:-}„ÄèÔºåÂÆûÂæó„Äé${LAST_MEANINGFUL_LINE:-}„Äè"
  false
fi

# ---------- Ëß£ÊûêË°•‰∏Å ----------
files_todo=(); files_tmp=()
deletes_todo=()
moves_from=(); moves_to=()
blocks_path=(); blocks_anchor=(); blocks_mode=(); blocks_tmp=(); blocks_index=()
diffs_tmp=(); diffs_opts=()

in_block=0; cur_path=""; cur_tmp=""; cur_anchor=""; cur_mode=""; cur_index=""; cur_diff_opts=""

while IFS= read -r raw || [[ -n "$raw" ]]; do
  line="${raw%$'\r'}"

  # file
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== file:'; then
    cur_path="$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== file:[[:space:]]*(.+)[[:space:]]*===$/\1/')")")"
    cur_tmp="$(mktemp)"; in_block=1; continue
  fi
  # delete
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== delete:'; then
    deletes_todo+=( "$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== delete:[[:space:]]*(.+)[[:space:]]*===$/\1/')")")" ); continue
  fi
  # mv
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== mv:'; then
    from="$(trim "$(echo "$line" | sed -E 's/^=== mv:[[:space:]]*(.+)[[:space:]]*=>[[:space:]]*(.+)[[:space:]]*===$/\1/')")"
    to="$(trim   "$(echo "$line" | sed -E 's/^=== mv:[[:space:]]*(.+)[[:space:]]*=>[[:space:]]*(.+)[[:space:]]*===$/\2/')")"
    moves_from+=( "$(norm_path "$from")" ); moves_to+=( "$(norm_path "$to")" ); continue
  fi
  # block
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== block:'; then
    cur_path="$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== block:[[:space:]]*([^#[:space:]]+)\#.*$/\1/')")")"
    cur_anchor="$(trim "$(echo "$line" | sed -E 's/^=== block:[[:space:]]*[^#]+#([A-Za-z0-9_-]+).*$/\1/')")"
    cur_mode="$(trim "$(echo "$line" | sed -E 's/^.*mode=(replace|append|prepend|append_once).*$/\1/')" )"; [[ -z "$cur_mode" ]] && cur_mode="replace"
    cur_index="$(echo "$line" | sed -nE 's/^=== block:[[:space:]]*[^#]+#[^[:space:]@]+@index=([0-9]+).*$/\1/p')"; [[ -z "$cur_index" ]] && cur_index="1"
    cur_tmp="$(mktemp)"; in_block=2; continue
  fi
  # diff
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== diff:'; then
    cur_diff_opts="$(trim "$(echo "$line" | sed -E 's/^=== diff:[[:space:]]*(.+)[[:space:]]*===$/\1/')" )"
    cur_tmp="$(mktemp)"; in_block=3; continue
  fi

  # end
  if [[ $in_block -eq 1 && "$line" == "=== end ===" ]]; then
    files_todo+=( "$cur_path" ); files_tmp+=( "$cur_tmp" ); in_block=0; cur_path=""; cur_tmp=""; continue
  fi
  if [[ $in_block -eq 2 && "$line" == "=== end ===" ]]; then
    blocks_path+=( "$cur_path" ); blocks_anchor+=( "$cur_anchor" ); blocks_mode+=( "$cur_mode" ); blocks_tmp+=( "$cur_tmp" ); blocks_index+=( "$cur_index" )
    in_block=0; cur_path=""; cur_tmp=""; cur_anchor=""; cur_mode=""; cur_index=""; continue
  fi
  if [[ $in_block -eq 3 && "$line" == "=== end ===" ]]; then
    diffs_tmp+=( "$cur_tmp" ); diffs_opts+=( "$cur_diff_opts" ); in_block=0; cur_tmp=""; cur_diff_opts=""; continue
  fi

  # EOF
  if [[ "$line" == "${EOF_MARK:-}" ]]; then break; fi

  # ÂÜÖÂÆπÊî∂ÈõÜ
  if [[ $in_block -eq 1 || $in_block -eq 2 || $in_block -eq 3 ]]; then printf '%s\n' "$line" >>"$cur_tmp"; fi
done < "$PATCH_FILE"

if [[ $in_block -ne 0 ]]; then log "‚ùå Ë°•‰∏ÅÂùóÊú™Ê≠£Â∏∏ÁªìÊùü„ÄÇ"; false; fi

log "üì¶ ÁªüËÆ°Ôºöfile=${#files_todo[@]} delete=${#deletes_todo[@]} mv=${#moves_from[@]} block=${#blocks_path[@]} diff=${#diffs_tmp[@]}"

# ---------- ÊâßË°åÔºàËøõÂÖ•‰ªìÂ∫ì + Âπ≤ÂáÄÁ≠ñÁï• + ÂºÄÂêØ‰∫ãÂä°Ôºâ ----------
cd "$REPO"

# Âπ≤ÂáÄÁ≠ñÁï•
case "${REQUIRE_CLEAN:-1}" in
  auto)
    log "‚ÑπÔ∏è Ëá™Âä®Ê∏ÖÁêÜÔºögit reset --hard && git clean -fd"
    git reset --hard >/dev/null
    git clean -fd   >/dev/null
    ;;
  1|true|yes)
    if { ! git diff --quiet || ! git diff --cached --quiet; }; then
      log "‚ùå Â∑•‰ΩúÂå∫‰∏çÂπ≤ÂáÄÔºõ‰∏∫‰øùËØÅ‰∫ãÂä°ÊÄßÂ∑≤‰∏≠Ê≠¢ÔºàREQUIRE_CLEAN=auto ÂèØËá™Âä®Ê∏ÖÁêÜÔºå=0 ÂøΩÁï•Ôºâ"
      false
    fi
    ;;
  0|false|no) : ;;
  *)
    log "‚ö†Ô∏è Êú™Áü• REQUIRE_CLEAN='${REQUIRE_CLEAN:-}'ÔºåÊåâÈªòËÆ§ 1 Â§ÑÁêÜ"
    if { ! git diff --quiet || ! git diff --cached --quiet; }; then
      log "‚ùå Â∑•‰ΩúÂå∫‰∏çÂπ≤ÂáÄÔºõ‰∏∫‰øùËØÅ‰∫ãÂä°ÊÄßÂ∑≤‰∏≠Ê≠¢"; false
    fi
    ;;
esac

# ‰∫ãÂä°Ëµ∑ÁÇπ + ÂõûÊªöÂô®ÔºàERR & EXIT ÂÖúÂ∫ïÔºâ
START_HEAD="$(git rev-parse --verify HEAD 2>/dev/null || true)"
TX_DONE=0
rollback(){
  git reset --hard "${START_HEAD:-HEAD}" >/dev/null 2>&1 || true
  git clean -fd >/dev/null 2>&1 || true
  log "‚Ü©Ô∏è Â∑≤ÂõûÊªöÂà∞ ${START_HEAD:-HEAD}"
}
trap 'log "‚ùå Âá∫ÈîôÔºåÂõûÊªö‰∏≠‚Ä¶"; rollback' ERR
trap 'rc=$?; if [[ $rc -ne 0 && ${TX_DONE:-0} -eq 0 ]]; then log "‚ö†Ô∏è ÈùûÈõ∂ÈÄÄÂá∫($rc)ÔºåÊâßË°åÂÖúÂ∫ïÂõûÊªö‚Ä¶"; rollback; fi; cleanup_lock' EXIT

# ---------- mv / delete ----------
for (( i=0; i<${#moves_from[@]:-0}; i++ )); do
  from="${moves_from[$i]-}"; to="${moves_to[$i]-}"
  [[ -z "${from:-}" || -z "${to:-}" ]] && continue
  ensure_canonical_in_repo "$from"; ensure_canonical_in_repo "$to"
  if [[ -e "$from" ]]; then mkdir -p "$(dirname "$to")"; git mv -f "$from" "$to" || true; log "üîÅ ÊîπÂêçÔºö$from => $to"
  else log "‚ÑπÔ∏è Ë∑≥ËøáÊîπÂêçÔºà‰∏çÂ≠òÂú®ÔºâÔºö$from"; fi
done

for d in "${deletes_todo[@]:-}"; do
  [[ -z "${d:-}" ]] && continue
  ensure_canonical_in_repo "$d"
  if [[ -e "$d" ]]; then git rm -f "$d" || true; log "üóëÔ∏è Âà†Èô§Ôºö$d"
  else log "‚ÑπÔ∏è Ë∑≥ËøáÂà†Èô§Ôºà‰∏çÂ≠òÂú®ÔºâÔºö$d"; fi
done

# ---------- file ÂÜôÂÖ• ----------
for (( i=0; i<${#files_todo[@]:-0}; i++ )); do
  p="${files_todo[$i]-}"; tmp="${files_tmp[$i]-}"
  [[ -z "${p:-}" || -z "${tmp:-}" ]] && continue
  ensure_canonical_in_repo "$p"; mkdir -p "$(dirname "$p")"
  LC_ALL=C sed -e 's/\r$//' <"$tmp" >"$p"
  if [ -s "$p" ] && [ "$(tail -c1 "$p" 2>/dev/null | wc -c)" -ne 0 ]; then printf '\n' >>"$p"; fi
  git add "$p"; log "‚úÖ ÂÜôÂÖ•Êñá‰ª∂Ôºö$p"
done
for t in "${files_tmp[@]:-}"; do rm -f "$t" 2>/dev/null || true; done

# ---------- block Â∫îÁî®ÔºàÂµåÂ•ó + ÂºïÂØº + append_onceÔºâ ----------
apply_block(){
  local rel="$1" anchor="$2" mode="$3" content_file="$4" index="${5:-1}"
  local file="$REPO/$rel"
  [[ -e "$file" ]] || { mkdir -p "$(dirname "$file")"; :> "$file"; }

  locate_and_apply(){
    local file="$1" anchor="$2" mode="$3" content_file="$4" index="$5"
    read -r start end total < <(python3 - "$file" "$anchor" "$index" <<'PY'
import sys,re
path,anchor,idx=sys.argv[1],sys.argv[2],int(sys.argv[3])
rb=re.compile(r'XGIT:\s*BEGIN\s+'+re.escape(anchor)+r'\b',re.I)
re_=re.compile(r'XGIT:\s*END\s+'  +re.escape(anchor)+r'\b',re.I)
lines=open(path,'rb').read().decode('utf-8','replace').splitlines()
pairs=[]; stack=[]
for i,l in enumerate(lines,1):
    if rb.search(l): stack.append(i)
    if re_.search(l) and stack:
        s=stack.pop(); pairs.append((s,i))
pairs.sort(key=lambda p:p[0])
total=len(pairs)
if 1<=idx<=total: print(pairs[idx-1][0], pairs[idx-1][1], total)
else:             print('', '', total)
PY
)
    [[ -z "${start:-}" || -z "${end:-}" ]] && return 1

    local head_file body_file tail_file norm_content out begin_line end_line
    head_file="$(mktemp)"; body_file="$(mktemp)"; tail_file="$(mktemp)"; norm_content="$(mktemp)"; out="$(mktemp)"
    awk -v s="$start"        'NR < s' "$file" >"$head_file"
    awk -v s="$start" -v e="$end" 'NR> s && NR< e' "$file" >"$body_file"
    awk -v e="$end"          'NR > e' "$file" >"$tail_file"
    LC_ALL=C sed -e 's/\r$//' <"$content_file" >"$norm_content"
    begin_line="$(sed -n "${start}p" "$file")"; end_line="$(sed -n   "${end}p"   "$file")"

    if [[ "$mode" == "append_once" ]]; then
      if python3 - "$body_file" "$norm_content" <<'PY'
import sys
b=open(sys.argv[1],'rb').read().replace(b'\r',b'')
c=open(sys.argv[2],'rb').read().replace(b'\r',b'')
def norm(x): return b'\n'.join(ln.rstrip() for ln in x.splitlines())
sys.exit(0 if norm(c) in norm(b) else 1)
PY
      then
        out="$(mktemp)"; sed -n "1,${start}p" "$file" >"$out"; cat "$body_file" >>"$out"; sed -n "${end},\$p" "$file" >>"$out"
        mv -f "$out" "$file"; rm -f "$head_file" "$body_file" "$tail_file" "$norm_content"
        log "‚ÑπÔ∏è append_onceÔºöÂÜÖÂÆπÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÔºà$rel #$anchor @index=$indexÔºâ"; return 0
      fi
    fi

    sed -n "1,${start}p" "$file" >"$out"
    printf '%s\n' "$begin_line" >>"$out"
    case "$mode" in
      replace)     cat "$norm_content" >>"$out" ;;
      append)      cat "$body_file" >>"$out"; cat "$norm_content" >>"$out" ;;
      append_once) cat "$body_file" >>"$out"; cat "$norm_content" >>"$out" ;;
      prepend)     cat "$norm_content" >>"$out"; cat "$body_file" >>"$out" ;;
      *)           cat "$norm_content" >>"$out" ;;
    esac
    printf '%s\n' "$end_line" >>"$out"
    sed -n "${end},\$p" "$file" >>"$out"

    mv -f "$out" "$file"
    rm -f "$head_file" "$body_file" "$tail_file" "$norm_content"
    log "üß© ÂëΩ‰∏≠ÈîöÂå∫Ôºö$rel #$anchor (mode=$mode)"
    return 0
  }

  # È¶ñÊ¨°Â∞ùËØï
  if locate_and_apply "$file" "$anchor" "$mode" "$content_file" "$index"; then return 0; fi

  # Ëá™Âä®ÂºïÂØºÔºàÂ§±Ë¥•ÂèØÂõûÊªöÔºâ
  local booted=0
  {
    printf '\n<!-- XGIT:BEGIN %s -->\n' "$anchor"
    printf '<!-- XGIT:END %s -->\n' "$anchor"
  } >>"$file" && booted=1
  log "‚ÑπÔ∏è Ëá™Âä®ÂºïÂØºÁ©∫ÈîöÁÇπÔºö$rel #$anchor (@index=$index)"

  # ÂºïÂØºÂêé‰ºòÂÖàÂëΩ‰∏≠ÊúÄÂêé‰∏Ä‰∏™
  read -r _s _e total < <(python3 - "$file" "$anchor" 1 <<'PY'
import sys,re
path,anchor=sys.argv[1],sys.argv[2]
rb=re.compile(r'XGIT:\s*BEGIN\s+'+re.escape(anchor)+r'\b',re.I)
re_=re.compile(r'XGIT:\s*END\s+'  +re.escape(anchor)+r'\b',re.I)
lines=open(path,'rb').read().decode('utf-8','replace').splitlines()
pairs=[]; stack=[]
for i,l in enumerate(lines,1):
    if rb.search(l): stack.append(i)
    if re_.search(l) and stack:
        s=stack.pop(); pairs.append((s,i))
print(0,0,len(pairs))
PY
)
  if [[ "${total:-0}" -ge 1 ]]; then
    if locate_and_apply "$file" "$anchor" "$mode" "$content_file" "$total"; then return 0; fi
  fi

  # ÂõûÊªöÂàöÂºïÂØºÁöÑÈîöÁÇπÔºàÈÅøÂÖçÂçäÊàêÂìÅÔºâ
  if [[ "$booted" -eq 1 ]]; then
    local l1="<!-- XGIT:BEGIN ${anchor} -->"
    local l2="<!-- XGIT:END ${anchor} -->"
    local tail2; tail2="$(tail -n 2 "$file" 2>/dev/null || true)"
    if printf '%s\n' "$tail2" | grep -Fqx "$l1"$'\n'"$l2"; then
      local n; n="$(wc -l < "$file" | tr -d ' ')"
      if [[ "${n:-0}" -ge 2 ]]; then head -n $((n-2)) "$file" >"$file.tmp" && mv -f "$file.tmp" "$file"; log "‚Ü©Ô∏è ÂõûÊªöÂºïÂØºÈîöÁÇπÔºö$rel #$anchor"; fi
    fi
  fi

  log "‚ùå Êú™ÊâæÂà∞ÈîöÂå∫Êàñ index Ë∂ÖÁïåÔºö$rel #$anchor @index=$index"; return 1
}

for (( i=0; i<${#blocks_path[@]:-0}; i++ )); do
  p="${blocks_path[$i]-}"; a="${blocks_anchor[$i]-}"; m="${blocks_mode[$i]-}"
  tmp="${blocks_tmp[$i]-}"; idx="${blocks_index[$i]-}"   # @index 1-based
  [[ -z "${p:-}" || -z "${a:-}" || -z "${tmp:-}" || -z "${idx:-}" ]] && continue
  ensure_canonical_in_repo "$p"; mkdir -p "$(dirname "$p")"
  if apply_block "$p" "$a" "$m" "$tmp" "$idx"; then git add "$p"; log "‚úÖ Âå∫ÂùóÔºö$p #$a ($m @index=$idx)"
  else log "‚ùå Âå∫ÂùóÂ§±Ë¥•Ôºö$p #$a ($m @index=$idx)"; false; fi
done
for t in "${blocks_tmp[@]:-}"; do rm -f "$t" 2>/dev/null || true; done

# ---------- diffÔºàÁªü‰∏ÄË°•‰∏ÅÔºõopts Áº∫ÁúÅÂÆâÂÖ®Ôºâ ----------
apply_diff(){
  local tmp="${1-}"; local opts="${2-}"
  local mode="apply" strip="1" whitespace="nowarn" threeway="0" reverse="0" subpath=""
  for tok in ${opts:-}; do
    case "$tok" in
      mode=*) mode="${tok#mode=}" ;;
      strip=*) strip="${tok#strip=}" ;;
      whitespace=*) whitespace="${tok#whitespace=}" ;;
      threeway=1|threeway=true) threeway="1" ;;
      reverse=1|reverse=true) reverse="1" ;;
      path=*) subpath="$(trim "${tok#path=}")" ;;
    esac
  done
  local args=(--index "-p${strip}" "--whitespace=${whitespace}")
  [[ "${threeway:-0}" == "1" ]] && args+=("-3")
  if [[ "$reverse" == "1" || "$mode" == "reverse" ]]; then args+=(--reverse); fi
  local workdir="$REPO"; [[ -n "$subpath" ]] && workdir="$REPO/$subpath"
  if ! git -C "$workdir" apply --check "${args[@]}" "$tmp" >/dev/null 2>&1; then
    log "‚ùå git apply --check Â§±Ë¥•Ôºö${opts:-<none>}"
    git -C "$workdir" apply --check "${args[@]}" "$tmp" || true
    return 1
  fi
  git -C "$workdir" apply "${args[@]}" "$tmp"
  log "‚úÖ Â∑≤Â∫îÁî® diffÔºà${opts:-<none>}Ôºâ"
  return 0
}
for (( i=0; i<${#diffs_tmp[@]:-0}; i++ )); do
  dt="${diffs_tmp[$i]-}"; dopts="${diffs_opts[$i]-}"
  [[ -z "${dt:-}" ]] && continue
  if ! apply_diff "$dt" "${dopts-}"; then log "‚ùå diff Â∫îÁî®Â§±Ë¥•Ôºö${dopts-}"; false; fi
done
for t in "${diffs_tmp[@]:-}"; do rm -f "$t" 2>/dev/null || true; done

# ---------- Êèê‰∫§ & Êé®ÈÄÅÔºà‰∫ãÂä°Êî∂Â∞æÔºâ ----------
if git diff --cached --quiet; then
  log "‚ÑπÔ∏è Êó†ÊîπÂä®ÈúÄË¶ÅÊèê‰∫§„ÄÇ"
  TX_DONE=1
  log "================ patch.sh end ================"
  exit 0
fi

if [[ -n "${AUTHOR_LINE:-}" ]]; then git commit --author "$AUTHOR_LINE" -m "${COMMIT_MSG:-chore: apply patch}" >/dev/null
else git commit -m "${COMMIT_MSG:-chore: apply patch}" >/dev/null; fi
log "‚úÖ Â∑≤Êèê‰∫§Ôºö${COMMIT_MSG:-chore: apply patch}"

if [[ "${PUSH:-1}" == "1" ]]; then
  log "üöÄ Ê≠£Âú®Êé®ÈÄÅ‚Ä¶"
  if git push origin HEAD >/dev/null; then
    log "üöÄ Êé®ÈÄÅÂÆåÊàê"
    TX_DONE=1
  else
    log "‚ùå Êé®ÈÄÅÂ§±Ë¥•ÔºõÂºÄÂßãÂõûÊªö"
    rollback; TX_DONE=1; exit 1
  fi
else
  log "‚ÑπÔ∏è Â∑≤Á¶ÅÁî®Êé®ÈÄÅÔºàPUSH=0Ôºâ"
  TX_DONE=1
fi

log "================ patch.sh end ================"

