#!/usr/bin/env bash
# XGit patch.sh (STRICT v1.3, Bash 3.2 compatible, nested anchors, @index, append_once)
set -euo pipefail
IFS=$'\n\t'

# ---------- Âü∫Êú¨Ë∑ØÂæÑ ----------
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd -P)"
PATCH_FILE_DEFAULT="${SCRIPT_DIR}/ÊñáÊú¨.txt"
PATCH_FILE="${PATCH_FILE:-$PATCH_FILE_DEFAULT}"
LOG_FILE="${SCRIPT_DIR}/patch.log"
LOCK_DIR="${SCRIPT_DIR}/.patch.lock"

ts(){ date '+%F %T'; }
log(){ echo "$(ts) $*" | tee -a "$LOG_FILE"; }

# ---------- ÂçïÂÆû‰æãÈîÅ ----------
if ! mkdir "$LOCK_DIR" 2>/dev/null; then
  log "‚ùå Â∑≤Êúâ patch ÂÆû‰æãÂú®ËøêË°åÔºåÈÄÄÂá∫„ÄÇ"
  exit 1
fi
trap 'rmdir "$LOCK_DIR" 2>/dev/null || true' EXIT INT TERM

# ---------- Ë°•‰∏ÅÂ≠òÂú®ÊÄß ----------
if [[ ! -f "$PATCH_FILE" ]]; then
  log "‚ÑπÔ∏è Êú™ÊâæÂà∞Ë°•‰∏ÅÊñá‰ª∂Ôºö$PATCH_FILE"
  log "================ patch.sh end ================"
  exit 0
fi

# ---------- Â∑•ÂÖ∑ ----------
trim(){ # Âéª \r ‰∏éÂâçÂêéÁ©∫ÁôΩ
  local s="${1%$'\r'}"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}
lower(){ printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }
upper(){ printf '%s' "$1" | tr '[:lower:]' '[:upper:]'; }

norm_path(){ # Ê†áÂáÜÂåñË∑ØÂæÑ + Êñá‰ª∂ÂêçÂ§ßÂ∞èÂÜôËßÑËåÉ
  local p="$(trim "$1")"
  p="$(printf '%s' "$p" | sed 's#//*#/#g; s#^\./##')"
  local dir base name ext ext_l
  dir="$(dirname "$p")"; base="$(basename "$p")"
  if [[ "$base" == *.* ]]; then name="${base%.*}"; ext="${base##*.}"; else name="$base"; ext=""; fi
  ext_l="$(lower "$ext")"
  if [[ -z "$ext" || "$ext_l" == "md" ]]; then
    name="$(upper "$name")"
  else
    name="$(lower "$name")"
  fi
  local base2="$name"; [[ -n "$ext_l" ]] && base2="${name}.${ext_l}"
  [[ "$dir" == "." ]] && printf '%s\n' "$base2" || printf '%s/%s\n' "$dir" "$base2"
}

ensure_canonical_in_repo(){ # ‰øÆÊ≠£Â§ßÂ∞èÂÜôÂ∑ÆÂºÇ
  local want="$1"; local abs="$REPO/$want"
  mkdir -p "$(dirname "$abs")"
  if [[ -e "$abs" ]]; then return 0; fi
  local parent leaf hit
  parent="$(dirname "$want")"; leaf="$(basename "$want")"
  hit="$( (cd "$REPO/$parent" 2>/dev/null && find . -maxdepth 1 -iname "$leaf" -print | sed 's#^\./##') || true )"
  if [[ -n "$hit" && "$hit" != "$leaf" && -e "$REPO/$parent/$hit" ]]; then
    ( cd "$REPO" && git mv -f "$parent/$hit" "$want" ) || true
  fi
}

# ---------- ËØªÂèñË°•‰∏ÅÂ§¥Â≠óÊÆµ ----------
first_field(){ sed -n "s/^$1:[[:space:]]*//p; q" "$PATCH_FILE" | head -n1; }

# ---------- ‰ªìÂ∫ìÂÆö‰Ωç ----------
find_git_root(){ local s="$1"; while [[ -n "$s" && "$s" != "/" ]]; do [[ -d "$s/.git" ]] && { echo "$s"; return 0; }; s="$(dirname "$s")"; done; return 1; }
is_repo(){ git -C "$1" rev-parse --is-inside-work-tree >/dev/null 2>&1; }

PATCH_DIR="$(cd "$(dirname "$PATCH_FILE")" && pwd -P)"
MAP_PATCH="$PATCH_DIR/.repos"
MAP_SCRIPT="$SCRIPT_DIR/.repos"
MAP_GLOBAL="$HOME/.config/xgit/repos"
CACHE_PATCH="$PATCH_DIR/.repo"
CACHE_GLOBAL="$HOME/.config/xgit/repo"

repo_from_maps(){ # ËØªÂèñ name->path Êò†Â∞Ñ‰∏é default
  local name="$1"; local f line k v
  for f in "$MAP_PATCH" "$MAP_SCRIPT" "$MAP_GLOBAL"; do
    [[ -f "$f" ]] || continue
    while IFS= read -r line || [[ -n "$line" ]]; do
      line="${line%%#*}"; line="${line%%;*}"; line="$(trim "$line")"
      [[ -z "$line" ]] && continue
      if echo "$line" | grep -qE '^[[:space:]]*default[[:space:]]*='; then
        k="default"; v="$(echo "$line" | sed -E 's/^[[:space:]]*default[[:space:]]*=[[:space:]]*(\S+).*/\1/')"
        [[ "$name" == "default" ]] && { printf '%s\n' "$v"; return 0; }
      elif echo "$line" | grep -qE '^[^=[:space:]]+[[:space:]]*='; then
        k="$(echo "$line" | sed -E 's/^([^=[:space:]]+).*/\1/')"
        v="$(echo "$line" | sed -E 's/^[^=[:space:]]+[[:space:]]*=[[:space:]]*(.+)$/\1/')"
        [[ "$k" == "$name" ]] && { printf '%s\n' "$v"; return 0; }
      elif echo "$line" | grep -qE '^[^[:space:]]+[[:space:]]+/'; then
        k="$(echo "$line" | awk '{print $1}')"
        v="$(echo "$line" | sed -E 's/^[^[:space:]]+[[:space:]]+(.+)$/\1/')"
        [[ "$k" == "$name" ]] && { printf '%s\n' "$v"; return 0; }
      fi
    done < "$f"
  done
  return 1
}

scan_sibling_repo(){ # ÂÖÑÂºüÁõÆÂΩï‰ªÖ‰∏Ä‰∏™Âê´ .git ÁöÑÂ≠êÁõÆÂΩïÊó∂ËøîÂõûÂÆÉ
  local base="$1"; local parent="$(dirname "$base")"; local hits=0 last=""
  while IFS= read -r d; do
    [[ -d "$d/.git" ]] || continue
    hits=$((hits+1)); last="$d"
  done < <(find "$parent" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)
  [[ $hits -eq 1 ]] && printf '%s\n' "$last" || printf '%s\n' ""
}

# ÂÄôÈÄâÈõÜÂêà
candidates=()
# 1) ÁéØÂ¢ÉÂèòÈáè
[[ -n "${REPO:-}" ]] && candidates+=("$(trim "$REPO")")

# 2) Ë°•‰∏ÅÂ§¥ repo:
REPO_HDR="$(trim "$(first_field repo || true)")"
if [[ -n "$REPO_HDR" ]]; then
  if [[ "$REPO_HDR" = /* ]]; then
    candidates+=("$REPO_HDR")
  else
    if MAP_PATH="$(repo_from_maps "$REPO_HDR" 2>/dev/null || true)"; then
      candidates+=("$MAP_PATH")
    elif MAP_DEF_NAME="$(repo_from_maps default 2>/dev/null || true)"; then
      if MAP_DEF_PATH="$(repo_from_maps "$MAP_DEF_NAME" 2>/dev/null || true)"; then
        candidates+=("$MAP_DEF_PATH")
      fi
    fi
  fi
fi

# 3) ÁºìÂ≠ò
[[ -f "$CACHE_PATCH"  ]] && candidates+=("$(trim "$(cat "$CACHE_PATCH")")")
[[ -f "$CACHE_GLOBAL" ]] && candidates+=("$(trim "$(cat "$CACHE_GLOBAL")")")

# 4) ÂÖÑÂºüÁõÆÂΩïÊâ´Êèè
sib1="$(scan_sibling_repo "$SCRIPT_DIR")"; [[ -n "$sib1" ]] && candidates+=("$sib1")
sib2="$(scan_sibling_repo "$PATCH_DIR")";  [[ -n "$sib2" ]] && candidates+=("$sib2")

# 5) Âêë‰∏äÊü•Êâæ
root1="$(find_git_root "$SCRIPT_DIR" || true)"; [[ -n "$root1" ]] && candidates+=("$root1")
root2="$(find_git_root "$PATCH_DIR"  || true)"; [[ -n "$root2" ]] && candidates+=("$root2")

# ÂéªÈáç & ÂÆû‰ΩìÂåñ
uniq_candidates=()
for c in "${candidates[@]:-}"; do
  [[ -z "$c" ]] && continue
  c="$(python3 - <<'PY' "$c"
import os,sys; print(os.path.realpath(sys.argv[1]))
PY
)"
  # Á∫øÊÄßÂéªÈáçÔºàbash3 ÂÖºÂÆπÔºâ
  skip=0
  for u in "${uniq_candidates[@]:-}"; do [[ "$u" == "$c" ]] && { skip=1; break; }; done
  [[ $skip -eq 1 ]] && continue
  uniq_candidates+=("$c")
done

REPO=""
for c in "${uniq_candidates[@]:-}"; do
  if is_repo "$c"; then REPO="$c"; break; fi
done
if [[ -z "$REPO" ]]; then
  log "‚ùå Êú™ËÉΩËá™Âä®ÂÆö‰Ωç Git ‰ªìÂ∫ìÊ†πÁõÆÂΩï„ÄÇÂèØÂú®Ë°•‰∏ÅÂ§¥ÂÜô repo: /abs/path Êàñ repo: <name>ÔºàÈÖçÂêà .reposÔºâÔºåÊàñÂØºÂá∫ REPO=/abs/path„ÄÇ"
  exit 1
fi
# ÂÜôÁºìÂ≠ò
mkdir -p "$(dirname "$CACHE_GLOBAL")"
printf '%s\n' "$REPO" >"$CACHE_PATCH"
printf '%s\n' "$REPO" >"$CACHE_GLOBAL"

log "================ patch.sh begin ================"
log "üìÇ ‰ªìÂ∫ìÊ†πÁõÆÂΩïÔºö$REPO"
log "üìÑ Ë°•‰∏ÅÊñá‰ª∂Ôºö$PATCH_FILE"

# ---------- ËØªÂèñÊèê‰∫§‰ø°ÊÅØ ----------
COMMIT_MSG="$(trim "$(first_field commitmsg || true)")"
AUTHOR_LINE="$(trim "$(first_field author || true)")"
log "üìù Êèê‰∫§ËØ¥ÊòéÔºö${COMMIT_MSG:-(Á©∫)}"
log "üë§ Êèê‰∫§‰ΩúËÄÖÔºö${AUTHOR_LINE:-(Á©∫)}"

# ---------- ‰∏•Ê†º EOF ----------
EOF_MARK="${EOF_MARK:-=== PATCH EOF ===}"
LAST_MEANINGFUL_LINE="$(awk 'NF{last=$0} END{print last}' "$PATCH_FILE")"
if [ "$LAST_MEANINGFUL_LINE" != "$EOF_MARK" ]; then
  log "‚ùå ‰∏•Ê†º EOF Ê†°È™åÂ§±Ë¥•ÔºöÊúüÊúõ„Äé$EOF_MARK„ÄèÔºåÂÆûÂæó„Äé$LAST_MEANINGFUL_LINE'}"
  exit 1
fi

# ---------- Ëß£ÊûêË°•‰∏Å ----------
files_todo=(); files_tmp=()
deletes_todo=()
moves_from=(); moves_to=()
blocks_path=(); blocks_anchor=(); blocks_mode=(); blocks_tmp=(); blocks_index=()

in_block=0; cur_path=""; cur_tmp=""
cur_anchor=""; cur_mode=""; cur_index=""

while IFS= read -r raw || [[ -n "$raw" ]]; do
  line="${raw%$'\r'}"

  # === file: path ===
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== file:'; then
    cur_path="$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== file:[[:space:]]*(.+)[[:space:]]*===$/\1/')")")"
    cur_tmp="$(mktemp)"; in_block=1; continue
  fi

  # === delete: path ===
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== delete:'; then
    deletes_todo+=( "$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== delete:[[:space:]]*(.+)[[:space:]]*===$/\1/')")")" ); continue
  fi

  # === mv: old => new ===
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== mv:'; then
    from="$(trim "$(echo "$line" | sed -E 's/^=== mv:[[:space:]]*(.+)[[:space:]]*=>[[:space:]]*(.+)[[:space:]]*===$/\1/')")"
    to="$(trim   "$(echo "$line" | sed -E 's/^=== mv:[[:space:]]*(.+)[[:space:]]*=>[[:space:]]*(.+)[[:space:]]*===$/\2/')")"
    moves_from+=( "$(norm_path "$from")" ); moves_to+=( "$(norm_path "$to")" ); continue
  fi

  # === block: path#anchor[@index=N] mode=... ===
  if [[ $in_block -eq 0 ]] && echo "$line" | grep -qE '^=== block:'; then
    cur_path="$(norm_path "$(trim "$(echo "$line" | sed -E 's/^=== block:[[:space:]]*([^#[:space:]]+)\#.*$/\1/')")")"
    cur_anchor="$(trim "$(echo "$line" | sed -E 's/^=== block:[[:space:]]*[^#]+#([A-Za-z0-9_-]+).*$/\1/')")"
    cur_mode="$(trim "$(echo "$line" | sed -E 's/^.*mode=(replace|append|prepend|append_once).*$/\1/')" )"
    [[ -z "$cur_mode" ]] && cur_mode="replace"
    cur_index="$(echo "$line" | sed -nE 's/^=== block:[[:space:]]*[^#]+#[^[:space:]@]+@index=([0-9]+).*$/\1/p')"
    [[ -z "$cur_index" ]] && cur_index="1"
    cur_tmp="$(mktemp)"; in_block=2; continue
  fi

  # === end ===
  if [[ $in_block -eq 1 && "$line" == "=== end ===" ]]; then
    files_todo+=( "$cur_path" ); files_tmp+=( "$cur_tmp" )
    in_block=0; cur_path=""; cur_tmp=""; continue
  fi
  if [[ $in_block -eq 2 && "$line" == "=== end ===" ]]; then
    blocks_path+=( "$cur_path" ); blocks_anchor+=( "$cur_anchor" ); blocks_mode+=( "$cur_mode" ); blocks_tmp+=( "$cur_tmp" ); blocks_index+=( "$cur_index" )
    in_block=0; cur_path=""; cur_tmp=""; cur_anchor=""; cur_mode=""; cur_index=""; continue
  fi

  # EOF -> ÁªìÊùüËß£Êûê
  if [[ "$line" == "$EOF_MARK" ]]; then break; fi

  # Êî∂ÈõÜÂùóÂÜÖÂÆπ
  if [[ $in_block -eq 1 || $in_block -eq 2 ]]; then printf '%s\n' "$line" >>"$cur_tmp"; fi
done < "$PATCH_FILE"

if [[ $in_block -ne 0 ]]; then log "‚ùå Ë°•‰∏ÅÂùóÊú™Ê≠£Â∏∏ÁªìÊùü„ÄÇ"; exit 1; fi

log "üì¶ ÁªüËÆ°Ôºöfile=${#files_todo[@]} delete=${#deletes_todo[@]} mv=${#moves_from[@]} block=${#blocks_path[@]}"

# ---------- ÊâßË°å ----------
cd "$REPO"

# ÊîπÂêç
for (( i=0; i<${#moves_from[@]:-0}; i++ )); do
  from="${moves_from[$i]-}"; to="${moves_to[$i]-}"
  [[ -z "${from:-}" || -z "${to:-}" ]] && continue
  ensure_canonical_in_repo "$from"; ensure_canonical_in_repo "$to"
  if [[ -e "$from" ]]; then
    mkdir -p "$(dirname "$to")"
    git mv -f "$from" "$to" || true
    log "üîÅ ÊîπÂêçÔºö$from => $to"
  else
    log "‚ÑπÔ∏è Ë∑≥ËøáÊîπÂêçÔºà‰∏çÂ≠òÂú®ÔºâÔºö$from"
  fi
done

# Âà†Èô§
for d in "${deletes_todo[@]:-}"; do
  [[ -z "${d:-}" ]] && continue
  ensure_canonical_in_repo "$d"
  if [[ -e "$d" ]]; then
    git rm -f "$d" || true
    log "üóëÔ∏è Âà†Èô§Ôºö$d"
  else
    log "‚ÑπÔ∏è Ë∑≥ËøáÂà†Èô§Ôºà‰∏çÂ≠òÂú®ÔºâÔºö$d"
  fi
done

# ÂÜôÊñá‰ª∂
for (( i=0; i<${#files_todo[@]:-0}; i++ )); do
  p="${files_todo[$i]-}"; tmp="${files_tmp[$i]-}"
  [[ -z "${p:-}" || -z "${tmp:-}" ]] && continue
  ensure_canonical_in_repo "$p"; mkdir -p "$(dirname "$p")"
  LC_ALL=C sed -e 's/\r$//' <"$tmp" >"$p"
  # Êú´Â∞æË°•Êç¢Ë°å
  if [ -s "$p" ] && [ "$(tail -c1 "$p" 2>/dev/null | wc -c)" -ne 0 ]; then printf '\n' >>"$p"; fi
  git add "$p"
  log "‚úÖ ÂÜôÂÖ•Êñá‰ª∂Ôºö$p"
done
for t in "${files_tmp[@]:-}"; do rm -f "$t" 2>/dev/null || true; done

# Âå∫ÂùóÂ∫îÁî®ÔºàÂµåÂ•ó/ÈáçÂ§çÈîöÁÇπÔºöÊîØÊåÅ @index=NÔºõappend_once ÂπÇÁ≠âÔºâ
apply_block(){
  # $1=file, $2=anchor, $3=mode, $4=content_file, $5=index (1-based)
  local file="$1" anchor="$2" mode="$3" content_file="$4" index="${5:-1}"

  # Ëã•Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàùÂßãÂåñÁ©∫ÈîöÂå∫
  if [[ ! -e "$file" ]]; then
    mkdir -p "$(dirname "$file")"
    {
      echo "<!-- XGIT:BEGIN ${anchor} -->"
      echo "<!-- XGIT:END ${anchor} -->"
    } >"$file"
  fi

  # Áî® Python ÂÅöÔºöÂ§ßÂ∞èÂÜô‰∏çÊïèÊÑüÂåπÈÖçÔºåÊ†àÂºèÂåπÈÖçÂµåÂ•óÂêåÂêçÈîöÁÇπÔºõËøîÂõûÁ¨¨ index ‰∏™ÂùóÁöÑËµ∑Ê≠¢Ë°åÂè∑
  read -r start end < <(python3 - "$file" "$anchor" "$index" <<'PY'
import sys,re
path,anchor,idx=sys.argv[1],sys.argv[2],int(sys.argv[3])
rx_begin=re.compile(r'XGIT:\s*BEGIN\s+'+re.escape(anchor)+r'\b',re.I)
rx_end  =re.compile(r'XGIT:\s*END\s+'  +re.escape(anchor)+r'\b',re.I)
with open(path,'rb') as f:
    lines=f.read().decode('utf-8','replace').splitlines()
pairs=[]; stack=[]
for i,l in enumerate(lines,1):
    if rx_begin.search(l): stack.append(i)
    if rx_end.search(l) and stack:
        s=stack.pop()
        pairs.append((s,i))
pairs.sort(key=lambda p:p[0])
if 1<=idx<=len(pairs):
    print(pairs[idx-1][0], pairs[idx-1][1])
else:
    print('', '')
PY
)

  if [[ -z "$start" || -z "$end" ]]; then
    log "‚ùå Êú™ÊâæÂà∞ÈîöÂå∫Êàñ index Ë∂ÖÁïåÔºö$file #$anchor @index=$index"; return 1
  fi

  # ÂàáÁâáÔºöÂèñÂá∫Â§¥/‰Ωì/Â∞æ‰∏é BEGIN/END ÂéüÊ†∑Ë°å
  local head_file body_file tail_file norm_content out begin_line end_line
  head_file="$(mktemp)"; body_file="$(mktemp)"; tail_file="$(mktemp)"; norm_content="$(mktemp)"; out="$(mktemp)"
  awk -v s="$start"        'NR < s' "$file" >"$head_file"
  awk -v s="$start" -v e="$end" 'NR> s && NR< e' "$file" >"$body_file"
  awk -v e="$end"          'NR > e' "$file" >"$tail_file"
  LC_ALL=C sed -e 's/\r$//' <"$content_file" >"$norm_content"
  begin_line="$(sed -n "${start}p" "$file")"
  end_line="$(sed -n   "${end}p"   "$file")"

  # ÂπÇÁ≠âÔºöappend_once Êó∂ÔºåËã•Êñ∞ÂÜÖÂÆπÂ∑≤Âú® body ‰∏≠ÔºåÁõ¥Êé•ÊãºÂõû‰∏çÂèòÂåñ
  if [[ "$mode" == "append_once" ]]; then
    if python3 - "$body_file" "$norm_content" <<'PY'
import sys
b=open(sys.argv[1],'rb').read().replace(b'\r',b'')
c=open(sys.argv[2],'rb').read().replace(b'\r',b'')
def norm(x): return b'\n'.join(ln.rstrip() for ln in x.splitlines())
bb=norm(b); cc=norm(c)
sys.exit(0 if cc in bb else 1)
PY
    then
      out="$(mktemp)"
      sed -n "1,${start}p" "$file" >"$out"
      cat "$body_file" >>"$out"
      sed -n "${end},\$p" "$file" >>"$out"
      mv -f "$out" "$file"
      rm -f "$head_file" "$body_file" "$tail_file" "$norm_content"
      log "‚ÑπÔ∏è append_onceÔºöÂÜÖÂÆπÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáËøΩÂä†Ôºà$file #$anchor @index=$indexÔºâ"
      return 0
    fi
  fi

  # ÈáçÊñ∞ÁªÑË£ÖÔºà‰øùÁïôÂéü BEGIN/END Ë°åÔºâ
  sed -n "1,${start}p" "$file" >"$out"
  printf '%s\n' "$begin_line" >>"$out"
  case "$mode" in
    replace)     cat "$norm_content" >>"$out" ;;
    append)      cat "$body_file" >>"$out"; cat "$norm_content" >>"$out" ;;
    append_once) cat "$body_file" >>"$out"; cat "$norm_content" >>"$out" ;;
    prepend)     cat "$norm_content" >>"$out"; cat "$body_file" >>"$out" ;;
    *)           cat "$norm_content" >>"$out" ;;
  esac
  printf '%s\n' "$end_line" >>"$out"
  sed -n "${end},\$p" "$file" >>"$out"

  mv -f "$out" "$file"
  rm -f "$head_file" "$body_file" "$tail_file" "$norm_content"
  return 0
}

for (( i=0; i<${#blocks_path[@]:-0}; i++ )); do
  p="${blocks_path[$i]-}"; a="${blocks_anchor[$i]-}"; m="${blocks_mode[$i]-}"
  tmp="${blocks_tmp[$i]-}"; idx="${blocks_index[$i]-1}"
  [[ -z "${p:-}" || -z "${a:-}" || -z "${tmp:-}" || -z "${idx:-}" ]] && continue
  ensure_canonical_in_repo "$p"; mkdir -p "$(dirname "$p")"
  if apply_block "$p" "$a" "$m" "$tmp" "$idx"; then
    git add "$p"; log "‚úÖ Âå∫ÂùóÔºö$p #$a ($m @index=$idx)"
  else
    log "‚ùå Âå∫ÂùóÂ§±Ë¥•Ôºö$p #$a ($m @index=$idx)"; exit 1
  fi
done
for t in "${blocks_tmp[@]:-}"; do rm -f "$t" 2>/dev/null || true; done

# ---------- Êèê‰∫§ & Êé®ÈÄÅÔºàÈªòËÆ§Êé®ÈÄÅÂºÄÂêØÔºâ ----------
if git diff --cached --quiet; then
  log "‚ÑπÔ∏è Êó†ÊîπÂä®ÈúÄË¶ÅÊèê‰∫§„ÄÇ"
  log "================ patch.sh end ================"
  exit 0
fi

if [[ -n "${AUTHOR_LINE:-}" ]]; then
  git commit --author "$AUTHOR_LINE" -m "${COMMIT_MSG:-chore: apply patch}" >/dev/null
else
  git commit -m "${COMMIT_MSG:-chore: apply patch}" >/dev/null
fi
log "‚úÖ Â∑≤Êèê‰∫§Ôºö${COMMIT_MSG:-chore: apply patch}"

if [[ "${PUSH:-1}" == "1" ]]; then
  log "üöÄ Ê≠£Âú®Êé®ÈÄÅ‚Ä¶"; if git push origin HEAD >/dev/null; then log "üöÄ Êé®ÈÄÅÂÆåÊàê"; else log "‚ùå Êé®ÈÄÅÂ§±Ë¥•"; exit 1; fi
else
  log "‚ÑπÔ∏è Â∑≤Á¶ÅÁî®Êé®ÈÄÅÔºàPUSH=0Ôºâ"
fi

log "================ patch.sh end ================"

